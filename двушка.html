<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–ö–æ—Ñ–µ-–¥—Ä–æ–º: –û–±–≥–æ–Ω</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- Firebase SDK (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
    body {
      background: #111;
      font-family: system-ui, sans-serif;
      color: #fff;
      touch-action: none;
    }
    #game {
      width: 100vw;
      height: 100vh;
      position: relative;
      overflow: hidden;
      background: radial-gradient(circle at top, #333 0, #111 60%);
      transition: background 0.2s ease, transform 0.2s ease;
    }

    /* –î–æ—Ä–æ–≥–∞ */
    #road {
      position: absolute;
      width: 70vw;
      max-width: 420px;
      height: 100%;
      background: #222;
      left: 50%;
      transform: translateX(-50%);
      border-left: 6px solid #777;
      border-right: 6px solid #777;
      overflow: hidden;
      transition: filter 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    /* –†–∞–∑–º–µ—Ç–∫–∞ */
    .lane-line {
      position: absolute;
      width: 4px;
      height: 40px;
      background: #ddd;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0.7;
    }

    /* –ú–∞—à–∏–Ω–∞ –∏–≥—Ä–æ–∫–∞ */
    #raceCar {
      position: absolute;
      width: 40px;
      height: 70px;
      background: #00c853;
      bottom: 160px;
      left: 0; /* –±–µ–∑ translateX */
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.6);
      display: none;
      overflow: hidden; /* —á—Ç–æ–±—ã –Ω–∏—Ç—Ä–æ-–±–∞—Ä –Ω–µ –≤—ã–ª–µ–∑–∞–ª */
    }

    /* –ù–∏—Ç—Ä–æ —à–∫–∞–ª–∞ –Ω–∞ –º–∞—à–∏–Ω–µ (—Å–ø—Ä–∞–≤–∞, –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è) */
    #nitroBarBg {
      position: absolute;
      right: 4px;
      top: 8px;
      width: 6px;
      height: 54px;
      border-radius: 999px;
      background: rgba(0,0,0,0.45);
      overflow: hidden;
    }
    #nitroBarFill {
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 0%;
      background: linear-gradient(to top, #ff6d00, #ffea00);
      box-shadow: 0 0 6px rgba(255,200,0,0.9);
      opacity: 0.3;
      transition: height 0.08s linear, opacity 0.08s linear;
    }

    /* –í—Ä–∞–∂–µ—Å–∫–∏–µ –º–∞—à–∏–Ω—ã */
    .enemy {
      position: absolute;
      width: 40px;
      height: 70px;
      background: #e53935;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.6);
    }

    /* –ë–æ–Ω—É—Å—ã (–∫–æ—Ñ–µ / –∂–∏–∑–Ω—å) */
    .bonus {
      position: absolute;
      width: 34px;
      height: 34px;
      border-radius: 50%;
      background: radial-gradient(circle at top, #ffe0b2 0, #ff9800 70%, #e65100 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: 0 0 10px rgba(255,152,0,0.8);
    }
    .bonus.heart {
      background: radial-gradient(circle at top, #ffcdd2 0, #e53935 60%, #b71c1c 100%);
    }

    /* HUD */
    #hud {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      font-size: 13px;
      z-index: 5;
      text-shadow: 0 0 4px #000;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 95vw;
    }
    #hud span.value {
      font-weight: 700;
    }

    /* –û–≤–µ—Ä–ª–µ–∏ */
    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.75);
      z-index: 10;
      text-align: center;
      padding: 20px;
    }

    /* –ó–∞–≥—Ä—É–∑–æ—á–Ω—ã–π —ç–∫—Ä–∞–Ω —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π —Ç–µ–∫—Å—Ç–∞ */
    #introScreen {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    #introScreen h1 {
      font-size: 26px;
      margin-bottom: 4px;
    }
    .intro-text {
      font-size: 18px;
      max-width: 280px;
      margin: 0 auto;
      opacity: 0;
      animation: fadeUp 2.2s ease-out forwards;
    }
    @keyframes fadeUp {
      0%   { opacity: 0; transform: translateY(16px); }
      60%  { opacity: 1; transform: translateY(0); }
      100% { opacity: 1; transform: translateY(0); }
    }

    button {
      border: none;
      padding: 10px 20px;
      border-radius: 999px;
      font-size: 16px;
      margin-top: 10px;
      background: #ffb300;
      color: #000;
      font-weight: 600;
      cursor: pointer;
    }
    button:active {
      transform: scale(0.96);
    }

    /* –≠–∫—Ä–∞–Ω Game Over */
    #gameOver {
      flex-direction: column;
      gap: 8px;
    }

    /* –õ–∏–¥–µ—Ä–±–æ—Ä–¥ */
    #leaderboard {
      margin-top: 10px;
      text-align: left;
      max-width: 260px;
      margin-left: auto;
      margin-right: auto;
      font-size: 14px;
    }
    #leaderboard h3 {
      margin: 6px 0;
      font-size: 16px;
      text-align: center;
    }
    #leaderboard ol {
      margin: 0;
      padding-left: 20px;
    }

    /* –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) */
    #raceControls {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 6;
    }
    .ctrl-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      background: rgba(255,255,255,0.12);
      color: #fff;
      font-size: 28px;
    }

    /* –í–∏–∑—É–∞–ª Nitro –∏ Slow-motion */
    .nitro-mode #road {
      background: #111;
      box-shadow: 0 0 40px rgba(255,120,0,0.9);
    }
    .slow-motion #road {
      filter: brightness(0.7);
    }

    /* –¢—Ä—è—Å–∫–∞ —ç–∫—Ä–∞–Ω–∞ –ø—Ä–∏ –∞–≤–∞—Ä–∏–∏ */
    .hit-shake {
      animation: hitShake 0.25s;
    }
    @keyframes hitShake {
      0%   { transform: translateX(0); }
      20%  { transform: translateX(-6px); }
      40%  { transform: translateX(6px); }
      60%  { transform: translateX(-4px); }
      80%  { transform: translateX(4px); }
      100% { transform: translateX(0); }
    }
  </style>
</head>
<body>
<div id="game">
  <div id="road">
    <div id="raceCar">
      <div id="nitroBarBg">
        <div id="nitroBarFill"></div>
      </div>
    </div>
  </div>

  <div id="hud">
    <div>–ò–≥—Ä–æ–∫: <span id="playerNameLabel" class="value">–ì–æ—Å—Ç—å</span></div>
    <div>–û–±–æ–≥–Ω–∞–ª: <span id="score" class="value">0</span></div>
    <div>–°–∫–æ—Ä–æ—Å—Ç—å: <span id="speed" class="value">0</span> –∫–º/—á</div>
    <div>–ñ–∏–∑–Ω–∏: <span id="lives" class="value">‚ù§Ô∏è</span></div>
    <div>–†–µ–∫–æ—Ä–¥: <span id="bestScore" class="value">0</span></div>
  </div>

  <!-- –ó–∞–≥—Ä—É–∑–æ—á–Ω—ã–π —ç–∫—Ä–∞–Ω -->
  <div id="introScreen" class="overlay" style="display:flex;">
    <div>
      <h1>–ö–æ—Ñ–µ-–¥—Ä–æ–º ‚òïüèÅ</h1>
      <p class="intro-text">
        –û–±—ä–µ–∑–∂–∞–π –º–∞—à–∏–Ω—ã, –ø–æ–∫–∞ –∂–¥—ë—à—å —Å–≤–æ–π –∫–æ—Ñ–µ.
      </p>

      <input id="playerNameInput"
             type="text"
             placeholder="–í–≤–µ–¥–∏ —Å–≤–æ—ë –∏–º—è"
             style="margin-top:12px;padding:8px 12px;border-radius:999px;border:none;width:220px;text-align:center;" />

      <button id="introBtn">–ü–æ–µ—Ö–∞–ª–∏</button>
    </div>
  </div>

  <!-- –≠–∫—Ä–∞–Ω Game Over -->
  <div id="gameOver" class="overlay">
    <h2>–§–∏–Ω–∏—à!</h2>
    <p>–°–µ–≥–æ–¥–Ω—è—à–Ω–∏–π –∑–∞–µ–∑–¥: <span id="finalScore">0</span> –º–∞—à–∏–Ω</p>
    <p>–¢–≤–æ–π —Ä–µ–∫–æ—Ä–¥: <span id="bestScoreEnd">0</span> –º–∞—à–∏–Ω</p>
    <p id="comment"></p>

    <div style="display:flex;flex-direction:column;gap:8px;margin-top:10px;">
      <button id="coffeeNotReadyBtn" style="background:#ffb300;">–ö–æ—Ñ–µ –µ—â—ë –Ω–µ –≥–æ—Ç–æ–≤</button>
      <button id="coffeeReadyBtn" style="background:#00e676;">–ö–æ—Ñ–µ –≥–æ—Ç–æ–≤</button>
      <button id="restartBtn" style="background:#ccc;">–ù–æ–≤—ã–π –∑–∞–µ–∑–¥</button>
    </div>

    <p id="coffeeMsg" style="margin-top:10px;font-size:16px;font-weight:500;"></p>

    <div id="leaderboard">
      <h3>–¢–æ–ø –ø–∏–ª–æ—Ç–æ–≤</h3>
      <ol id="leaderboardList"></ol>
    </div>
  </div>

  <!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) -->
  <div id="raceControls">
    <button class="ctrl-btn" id="leftBtn">‚óÄ</button>
    <button class="ctrl-btn" id="rightBtn">‚ñ∂</button>
  </div>
</div>

<script>
  /* ===== Firebase init c —Ç–≤–æ–∏–º config ===== */
  const firebaseConfig = {
    apiKey: "AIzaSyBNfjarQbrPjloE--eAtl-RXeW11uPPXdc",
    authDomain: "coffe-drom.firebaseapp.com",
    databaseURL: "https://coffe-drom-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "coffe-drom",
    storageBucket: "coffe-drom.firebasestorage.app",
    messagingSenderId: "510024503818",
    appId: "1:510024503818:web:83b2a5258a7426a4a485f3"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();
  const bestScoreRef = db.ref('coffeeRacer/globalBestScore');
  const scoresRef = db.ref('coffeeRacer/scores');

  /* ===== DOM ===== */
  const road = document.getElementById('road');
  const raceCar = document.getElementById('raceCar');
  const nitroBarFill = document.getElementById('nitroBarFill');

  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speed');
  const livesEl = document.getElementById('lives');
  const bestScoreEl = document.getElementById('bestScore');
  const playerNameLabel = document.getElementById('playerNameLabel');

  const introScreen = document.getElementById('introScreen');
  const introBtn = document.getElementById('introBtn');
  const playerNameInput = document.getElementById('playerNameInput');

  const gameOver = document.getElementById('gameOver');
  const finalScoreEl = document.getElementById('finalScore');
  const bestScoreEndEl = document.getElementById('bestScoreEnd');
  const commentEl = document.getElementById('comment');
  const coffeeMsg = document.getElementById('coffeeMsg');
  const coffeeNotReadyBtn = document.getElementById('coffeeNotReadyBtn');
  const coffeeReadyBtn = document.getElementById('coffeeReadyBtn');
  const restartBtn = document.getElementById('restartBtn');

  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const gameEl = document.getElementById('game');
  const leaderboardList = document.getElementById('leaderboardList');

  let playerName = '–ì–æ—Å—Ç—å';

  function vibrate(pattern) {
    if (navigator.vibrate) {
      navigator.vibrate(pattern);
    }
  }

  // –æ—Ç—Å—Ç—É–ø –æ—Ç –≤–Ω—É—Ç—Ä. –∫—Ä–∞—ë–≤ –¥–æ—Ä–æ–≥–∏ (–º–æ–∂–µ—à—å –ø–æ—Å—Ç–∞–≤–∏—Ç—å 2‚Äì4, –µ—Å–ª–∏ –Ω—É–∂–Ω–æ —á—É—Ç—å –Ω–µ –¥–æ—Ö–æ–¥–∏—Ç—å –¥–æ –∫—Ä–∞—è)
  const ROAD_MARGIN = 0;

  // —Å–æ—Å—Ç–æ—è–Ω–∏–µ –∏–≥—Ä—ã
  let laneLines = [];
  let enemies = [];
  let bonuses = [];
  let score = 0;
  let speed = 3;
  let maxSpeed = 9;
  let lastSpawn = 0;
  let spawnInterval = 900;
  let moveDirection = 0;
  const moveStep = 6;
  let running = false;
  let lastTime = 0;

  // –∂–∏–∑–Ω–∏
  let lives = 1;
  const maxLives = 3;
  let invulnerableUntil = 0;

  // —Ä–µ–∫–æ—Ä–¥ (–æ–±—â–∏–π, –∏–∑ Firebase)
  let bestScore = 0;

  // Nitro
  let isNitroActive = false;
  let nitroEndTime = 0;
  let nitroCooldownEndTime = 0;
  const NITRO_DURATION = 2500;
  const NITRO_COOLDOWN = 6000;
  const NITRO_MULTIPLIER = 2.2;

  // Slow-motion
  let isSlowMotionActive = false;
  let slowMotionEndTime = 0;
  const SLOW_MOTION_DURATION = 1200;
  const SLOW_MOTION_FACTOR = 0.5;

  function updateLivesHUD() {
    livesEl.textContent = lives > 0 ? '‚ù§Ô∏è'.repeat(lives) : '‚Äî';
  }

  function loadGlobalBestScore() {
    bestScoreRef.once('value').then(snapshot => {
      const val = snapshot.val();
      if (typeof val === 'number') {
        bestScore = val;
        bestScoreEl.textContent = bestScore;
      } else {
        bestScore = 0;
        bestScoreEl.textContent = '0';
      }
    }).catch(err => {
      console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ä–µ–∫–æ—Ä–¥ –∏–∑ Firebase', err);
    });
  }

  function updateGlobalBestScoreIfNeeded(score) {
    bestScoreRef.transaction(current => {
      if (current === null || typeof current !== 'number') {
        return score;
      }
      return score > current ? score : current;
    }).then(result => {
      if (result.committed) {
        const newBest = result.snapshot.val();
        bestScore = newBest;
        bestScoreEl.textContent = bestScore;
        bestScoreEndEl.textContent = bestScore;
      }
    }).catch(err => {
      console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ä–µ–∫–æ—Ä–¥ –≤ Firebase', err);
    });
  }

  function submitScore(name, score) {
    return scoresRef.push({
      name: name || '–ì–æ—Å—Ç—å',
      score,
      ts: firebase.database.ServerValue.TIMESTAMP
    });
  }

  function loadLeaderboard() {
    leaderboardList.innerHTML = '<li>–ó–∞–≥—Ä—É–∑–∫–∞...</li>';
    scoresRef
      .orderByChild('score')
      .limitToLast(10)
      .once('value')
      .then(snapshot => {
        const list = [];
        snapshot.forEach(child => {
          list.push(child.val());
        });
        list.reverse();

        leaderboardList.innerHTML = '';
        if (list.length === 0) {
          leaderboardList.innerHTML = '<li>–ü–æ–∫–∞ –Ω–∏–∫—Ç–æ –Ω–µ –∏–≥—Ä–∞–ª</li>';
          return;
        }
        list.forEach((item) => {
          const li = document.createElement('li');
          li.textContent = `${item.name || '–ì–æ—Å—Ç—å'} ‚Äî ${item.score}`;
          leaderboardList.appendChild(li);
        });
      })
      .catch(err => {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É –ª–∏–¥–µ—Ä–æ–≤', err);
        leaderboardList.innerHTML = '<li>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</li>';
      });
  }

  /* ===== –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è: –≤–Ω—É—Ç—Ä–µ–Ω–Ω—è—è —à–∏—Ä–∏–Ω–∞ –¥–æ—Ä–æ–≥–∏ ===== */
  function getRoadInnerMetrics() {
    const fullWidth = road.offsetWidth;   // —Å –±–æ—Ä–¥—é—Ä–∞–º–∏
    const innerWidth = road.clientWidth;  // –±–µ–∑ –±–æ—Ä–¥—é—Ä–æ–≤
    const border = (fullWidth - innerWidth) / 2;
    return { innerWidth, borderLeft: border };
  }

  /* ===== –†–∞–∑–º–µ—Ç–∫–∞ –¥–æ—Ä–æ–≥–∏ ===== */
  function createLaneLines() {
    const roadRect = road.getBoundingClientRect();
    const count = Math.ceil(roadRect.height / 80) + 2;
    laneLines.forEach(l => l.remove());
    laneLines = [];
    for (let i = 0; i < count; i++) {
      const line = document.createElement('div');
      line.className = 'lane-line';
      line.style.top = i * 80 + 'px';
      road.appendChild(line);
      laneLines.push(line);
    }
  }

  /* ===== –ü–æ–∑–∏—Ü–∏—è –º–∞—à–∏–Ω—ã –ø–æ —Ü–µ–Ω—Ç—Ä—É ===== */
  function resetRaceCar() {
    const { innerWidth } = getRoadInnerMetrics();
    const carWidth = raceCar.offsetWidth || 40;
    let x = (innerWidth - carWidth) / 2;
    if (x < ROAD_MARGIN) x = ROAD_MARGIN;
    if (x > innerWidth - carWidth - ROAD_MARGIN) {
      x = innerWidth - carWidth - ROAD_MARGIN;
    }
    raceCar.style.left = x + 'px';
  }

  /* ===== –°–ø–∞–≤–Ω –≤—Ä–∞–≥–æ–≤ –∏ –±–æ–Ω—É—Å–æ–≤ ===== */
  function spawnEnemy() {
    const enemy = document.createElement('div');
    enemy.className = 'enemy';

    const { innerWidth } = getRoadInnerMetrics();
    const lanes = [
      innerWidth * 0.22,
      innerWidth * 0.5,
      innerWidth * 0.78
    ];
    const lane = lanes[Math.floor(Math.random() * lanes.length)];

    enemy.style.left = (lane - enemy.offsetWidth / 2) + 'px';
    enemy.style.top = '-90px';
    road.appendChild(enemy);
    enemies.push({ el: enemy, y: -90, counted: false });

    if (Math.random() < 0.15) {
      spawnBonus();
    }
  }

  function spawnBonus() {
    const bonus = document.createElement('div');
    const { innerWidth } = getRoadInnerMetrics();

    const isHeart = Math.random() < 0.3;
    bonus.className = 'bonus' + (isHeart ? ' heart' : '');
    bonus.dataset.type = isHeart ? 'heart' : 'coffee';
    bonus.textContent = isHeart ? '‚ù§Ô∏è' : '‚òï';

    const minX = ROAD_MARGIN + 10;
    const maxX = innerWidth - ROAD_MARGIN - 10;
    const left = minX + Math.random() * (maxX - minX);
    bonus.style.left = left + 'px';
    bonus.style.top = '-60px';

    road.appendChild(bonus);
    bonuses.push({ el: bonus, y: -60 });
  }

  function isColliding(a, b) {
    return !(
      a.right < b.left ||
      a.left > b.right ||
      a.bottom < b.top ||
      a.top > b.bottom
    );
  }

  /* ===== –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: –º–∞—à–∏–Ω–∞ —Å—Ä–∞–∑—É –ø–æ–¥ –ø–∞–ª—å—Ü–µ–º ===== */
  function setCarXFromClientX(clientX) {
    if (!running) return;

    const rect = road.getBoundingClientRect();
    const carWidth = raceCar.offsetWidth || 40;
    const { innerWidth, borderLeft } = getRoadInnerMetrics();

    // –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –ø–∞–ª—å—Ü–∞ –æ—Ç–Ω–æ—Å–∏—Ç–µ–ª—å–Ω–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–π —á–∞—Å—Ç–∏ –¥–æ—Ä–æ–≥–∏
    let localX = clientX - rect.left - borderLeft;   // 0..innerWidth
    let x = localX - carWidth / 2;

    if (x < ROAD_MARGIN) x = ROAD_MARGIN;
    if (x > innerWidth - carWidth - ROAD_MARGIN) {
      x = innerWidth - carWidth - ROAD_MARGIN;
    }

    raceCar.style.left = x + 'px';
  }

  gameEl.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    setCarXFromClientX(e.clientX);
  }, { passive: false });

  gameEl.addEventListener('pointermove', (e) => {
    if (!running) return;
    e.preventDefault();
    setCarXFromClientX(e.clientX);
  }, { passive: false });

  // –ö–Ω–æ–ø–∫–∏ –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ
  leftBtn.addEventListener('pointerdown', () => { moveDirection = -1; });
  rightBtn.addEventListener('pointerdown', () => { moveDirection = 1; });
  ['pointerup','pointerleave','pointercancel'].forEach(ev => {
    leftBtn.addEventListener(ev, () => moveDirection = 0);
    rightBtn.addEventListener(ev, () => moveDirection = 0);
  });

  function moveRaceCarButtons() {
    if (!running) return;
    const carWidth = raceCar.offsetWidth || 40;
    const { innerWidth } = getRoadInnerMetrics();

    let x = raceCar.offsetLeft + moveDirection * moveStep;
    if (x < ROAD_MARGIN) x = ROAD_MARGIN;
    if (x > innerWidth - carWidth - ROAD_MARGIN) {
      x = innerWidth - carWidth - ROAD_MARGIN;
    }
    raceCar.style.left = x + 'px';
  }

  /* ===== Nitro (–¥–≤–æ–π–Ω–æ–π —Ç–∞–ø) + —à–∫–∞–ª–∞ ===== */
  let lastTapTime = 0;

  raceCar.addEventListener('pointerdown', (e) => {
    if (!running) return;
    const now = performance.now();
    if (now - lastTapTime < 300) {
      activateNitro(now);
    }
    lastTapTime = now;
  });

  raceCar.addEventListener('touchstart', (e) => {
    e.preventDefault();
  }, { passive: false });

  raceCar.addEventListener('dblclick', (e) => {
    e.preventDefault();
  }, { passive: false });

  function activateNitro(now) {
    if (!running) return;
    if (isNitroActive) return;
    if (now < nitroCooldownEndTime) return;
    isNitroActive = true;
    nitroEndTime = now + NITRO_DURATION;
    gameEl.classList.add('nitro-mode');
  }

  function updateNitroBar(timestamp) {
    if (!nitroBarFill) return;

    let ratio = 0;
    let opacity = 0.3;

    if (isNitroActive) {
      const remaining = Math.max(0, nitroEndTime - timestamp);
      ratio = remaining / NITRO_DURATION;
      opacity = 1;
    } else if (timestamp < nitroCooldownEndTime) {
      const elapsed = NITRO_COOLDOWN - (nitroCooldownEndTime - timestamp);
      ratio = Math.max(0, Math.min(1, elapsed / NITRO_COOLDOWN));
      opacity = 0.6;
    } else {
      ratio = 1;
      opacity = 1;
    }

    nitroBarFill.style.height = (ratio * 100) + '%';
    nitroBarFill.style.opacity = opacity;
  }

  /* ===== Slow motion ===== */
  function triggerSlowMotion(timestamp) {
    isSlowMotionActive = true;
    slowMotionEndTime = timestamp + SLOW_MOTION_DURATION;
    gameEl.classList.add('slow-motion');
  }

  function handleCollision(timestamp, enemyIndex) {
    if (timestamp < invulnerableUntil) return;

    if (enemyIndex != null && enemies[enemyIndex]) {
      enemies[enemyIndex].el.remove();
      enemies.splice(enemyIndex, 1);
    }

    lives--;
    updateLivesHUD();
    vibrate([120, 60, 120]);
    triggerSlowMotion(timestamp);
    invulnerableUntil = timestamp + 1500;

    if (lives <= 0) {
      endGame();
    }
  }

  /* ===== –û—Å–Ω–æ–≤–Ω–æ–π –∞–ø–¥–µ–π—Ç ===== */
  function updateGame(timestamp, delta) {
    let speedFactor = 1;

    if (isSlowMotionActive) {
      if (timestamp >= slowMotionEndTime) {
        isSlowMotionActive = false;
        gameEl.classList.remove('slow-motion');
      } else {
        speedFactor = SLOW_MOTION_FACTOR;
      }
    }

    if (isNitroActive) {
      if (timestamp >= nitroEndTime) {
        isNitroActive = false;
        nitroCooldownEndTime = timestamp + NITRO_COOLDOWN;
        gameEl.classList.remove('nitro-mode');
      } else {
        speedFactor = NITRO_MULTIPLIER;
      }
    }

    updateNitroBar(timestamp);

    const effectiveSpeed = speed * speedFactor;
    const kmh = Math.round(effectiveSpeed * 20);
    speedEl.textContent = kmh;

    laneLines.forEach(line => {
      let top = parseFloat(line.style.top);
      top += effectiveSpeed * 2;
      const roadRect = road.getBoundingClientRect();
      if (top > roadRect.height) top = -40;
      line.style.top = top + 'px';
    });

    moveRaceCarButtons();

    const roadRect = road.getBoundingClientRect();
    const playerRect = raceCar.getBoundingClientRect();
    const playerCenterX = (playerRect.left + playerRect.right) / 2;

    // –≤—Ä–∞–≥–∏
    for (let i = enemies.length - 1; i >= 0; i--) {
      const obj = enemies[i];
      obj.y += effectiveSpeed * 2.2;
      obj.el.style.top = obj.y + 'px';

      const enemyRect = obj.el.getBoundingClientRect();

      if (isColliding(playerRect, enemyRect)) {
        handleCollision(timestamp, i);
        if (!running || lives <= 0) return;
        continue;
      }

      if (!obj.counted && enemyRect.top > playerRect.bottom) {
        const enemyCenterX = (enemyRect.left + enemyRect.right) / 2;
        const dx = Math.abs(enemyCenterX - playerCenterX);
        const closeThreshold = 18;
        const gained = dx < closeThreshold ? 2 : 1;

        score += gained;
        scoreEl.textContent = score;
        obj.counted = true;

        if (score > 0 && score % 10 === 0 && speed < maxSpeed) {
          speed += 0.2;
          spawnInterval = Math.max(450, spawnInterval - 10);
        }
      }

      if (obj.y > roadRect.height + 100) {
        obj.el.remove();
        enemies.splice(i, 1);
      }
    }

    // –±–æ–Ω—É—Å—ã
    for (let i = bonuses.length - 1; i >= 0; i--) {
      const obj = bonuses[i];
      obj.y += effectiveSpeed * 1.4;
      obj.el.style.top = obj.y + 'px';

      const bonusRect = obj.el.getBoundingClientRect();
      if (isColliding(playerRect, bonusRect)) {
        const type = obj.el.dataset.type || 'coffee';
        if (type === 'coffee') {
          score += 5;
          scoreEl.textContent = score;
          vibrate(60);
          triggerSlowMotion(timestamp);
        } else if (type === 'heart') {
          if (lives < maxLives) {
            lives++;
            updateLivesHUD();
            vibrate(80);
          }
        }
        obj.el.remove();
        bonuses.splice(i, 1);
        continue;
      }

      if (obj.y > roadRect.height + 80) {
        obj.el.remove();
        bonuses.splice(i, 1);
      }
    }

    if (timestamp - lastSpawn > spawnInterval) {
      spawnEnemy();
      lastSpawn = timestamp;
    }
  }

  function gameLoop(timestamp) {
    if (!running) return;
    const delta = timestamp - lastTime;
    lastTime = timestamp;

    updateGame(timestamp, delta);

    requestAnimationFrame(gameLoop);
  }

  function startGame() {
    enemies.forEach(e => e.el.remove());
    enemies = [];
    bonuses.forEach(b => b.el.remove());
    bonuses = [];
    score = 0;
    speed = 3;
    spawnInterval = 900;
    moveDirection = 0;
    scoreEl.textContent = score;
    speedEl.textContent = '0';

    lives = 1;
    invulnerableUntil = 0;
    updateLivesHUD();

    createLaneLines();
    raceCar.style.display = 'block';
    resetRaceCar();

    gameOver.style.display = 'none';
    coffeeMsg.textContent = '';

    isNitroActive = false;
    nitroEndTime = 0;
    nitroCooldownEndTime = 0;
    isSlowMotionActive = false;
    slowMotionEndTime = 0;
    gameEl.classList.remove('nitro-mode');
    gameEl.classList.remove('slow-motion');
    updateNitroBar(performance.now());

    loadGlobalBestScore();

    running = true;
    lastTime = performance.now();
    lastSpawn = lastTime;
    requestAnimationFrame(gameLoop);
  }

  function endGame() {
    running = false;

    vibrate([80, 40, 120]);
    gameEl.classList.add('hit-shake');
    setTimeout(() => {
      gameEl.classList.remove('hit-shake');
    }, 250);

    finalScoreEl.textContent = score;

    updateGlobalBestScoreIfNeeded(score);
    submitScore(playerName, score).then(() => {
      loadLeaderboard();
    });

    let text = '';
    if (score < 10) text = '–ü–æ—Ö–æ–∂–µ, —Ç—ã —Ç–æ–ª—å–∫–æ –≤—ã–µ—Ö–∞–ª –∏–∑ –±–æ–∫—Å–∞.';
    else if (score < 25) text = '–ù–µ–ø–ª–æ—Ö–æ –≤–æ–¥–∏—à—å! üëå';
    else text = '–¢—ã –Ω–∞—Å—Ç–æ—è—â–∏–π –ø–∏–ª–æ—Ç –∞–≤—Ç–æ–¥—Ä–æ–º–∞! üòé';

    commentEl.textContent = text;
    coffeeMsg.textContent = '';
    gameOver.style.display = 'flex';
  }

  coffeeNotReadyBtn.onclick = () => {
    coffeeMsg.textContent = '–ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑, –µ—Å–ª–∏ –∫–æ—Ñ–µ –µ—â—ë –Ω–µ –≥–æ—Ç–æ–≤ ‚òï';
    setTimeout(() => {
      startGame();
    }, 1200);
  };

  coffeeReadyBtn.onclick = () => {
    coffeeMsg.textContent = '–ù–∞—Å–ª–∞–∂–¥–∞–π—Ç–µ—Å—å –Ω–∞–ø–∏—Ç–∫–æ–º ‚òï';
  };

  restartBtn.onclick = () => {
    coffeeMsg.textContent = '';
    startGame();
  };

  introBtn.onclick = () => {
    const name = (playerNameInput.value || '').trim();
    playerName = name || '–ì–æ—Å—Ç—å';
    playerNameLabel.textContent = playerName;
    introScreen.style.display = 'none';
    startGame();
  };

  /* ===== –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —Å–∫—Ä–æ–ª–ª–∞ –∏ –∑—É–º–∞ ===== */
  (function preventScrolling() {
    const block = (e) => e.preventDefault();

    window.addEventListener('scroll', block, { passive: false });
    window.addEventListener('wheel', block, { passive: false });
    window.addEventListener('touchmove', block, { passive: false });

    window.addEventListener('touchstart', (e) => {
      if (e.touches.length > 1) e.preventDefault();
    }, { passive: false });

    document.body.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });

    document.addEventListener('gesturestart', (e) => e.preventDefault(), { passive: false });

    document.addEventListener('dblclick', (e) => {
      e.preventDefault();
    }, { passive: false });
  })();
</script>
</body>
</html>
