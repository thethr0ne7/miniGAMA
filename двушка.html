<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <title>–ö–æ—Ñ–µ-–¥—Ä–æ–º: –û–±–≥–æ–Ω</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

  <!-- Firebase SDK (compat) -->
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>

  <style>
    * { box-sizing: border-box; }
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      overflow: hidden;
    }
    body {
      background: #111;
      font-family: system-ui, sans-serif;
      color: #fff;
      touch-action: none;
    }
    #game {
      width: 100vw;
      height: 100vh;
      position: relative;
      overflow: hidden;
      background: radial-gradient(circle at top, #333 0, #111 60%);
      transition: background 0.2s ease, transform 0.2s ease, filter 0.15s ease;
    }

    /* –î–æ—Ä–æ–≥–∞ */
    #road {
      position: absolute;
      width: 70vw;
      max-width: 420px; /* –æ—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–∫ —Ç—ã –∏ —Ö–æ—Ç–µ–ª */
      height: 100%;
      background: #222;
      left: 50%;
      transform: translateX(-50%);
      border-left: 6px solid #777;
      border-right: 6px solid #777;
      overflow: hidden;
      transition: filter 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }

    /* –†–∞–∑–º–µ—Ç–∫–∞ */
    .lane-line {
      position: absolute;
      width: 4px;
      height: 40px;
      background: #ddd;
      left: 50%;
      transform: translateX(-50%);
      opacity: 0.7;
    }

    /* –ú–∞—à–∏–Ω–∞ –∏–≥—Ä–æ–∫–∞ */
    #raceCar {
      position: absolute;
      width: 40px;
      height: 70px;
      background: #00c853;
      bottom: 150px;
      left: 0;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.6);
      display: none;
      overflow: hidden;
      transition: box-shadow 0.15s ease;
    }

    /* –ù–∏—Ç—Ä–æ —à–∫–∞–ª–∞ –Ω–∞ –º–∞—à–∏–Ω–µ (—Å–ø—Ä–∞–≤–∞, –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è) */
    #nitroBarBg {
      position: absolute;
      right: 4px;
      top: 8px;
      width: 6px;
      height: 54px;
      border-radius: 999px;
      background: rgba(0,0,0,0.45);
      overflow: hidden;
    }
    #nitroBarFill {
      position: absolute;
      left: 0;
      bottom: 0;
      width: 100%;
      height: 0%;
      background: linear-gradient(to top, #ff6d00, #ffea00);
      box-shadow: 0 0 6px rgba(255,200,0,0.9);
      opacity: 0.3;
      transition: height 0.08s linear, opacity 0.08s linear;
    }

    /* –ù–∏—Ç—Ä–æ –≥–æ—Ç–æ–≤–æ */
    #nitroBarFill.ready {
      animation: nitroPulse 0.8s ease-in-out infinite;
    }
    @keyframes nitroPulse {
      0% { box-shadow: 0 0 4px rgba(255,230,0,0.5); }
      100% { box-shadow: 0 0 14px rgba(255,230,0,1); }
    }

    /* –ù–∏—Ç—Ä–æ-—à–ª–µ–π—Ñ */
    #raceCar.nitro-trail {
      box-shadow:
        0 0 10px rgba(0,0,0,0.6),
        0 0 18px rgba(255,200,0,0.9);
    }

    /* –í—Ä–∞–≥–∏ */
    .enemy {
      position: absolute;
      width: 40px;
      height: 70px;
      background: #e53935;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0,0,0,0.6);
    }

    /* –ë–æ–Ω—É—Å—ã */
    .bonus {
      position: absolute;
      width: 34px;
      height: 34px;
      border-radius: 50%;
      background: radial-gradient(circle at top, #ffe0b2 0, #ff9800 70%, #e65100 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      box-shadow: 0 0 10px rgba(255,152,0,0.8);
    }
    .bonus.heart {
      background: radial-gradient(circle at top, #ffcdd2 0, #e53935 60%, #b71c1c 100%);
    }

    /* –õ—É–∂–∞ –º–æ–ª–æ–∫–∞ */
    .milk {
      position: absolute;
      width: 50px;
      height: 30px;
      border-radius: 50%;
      background: radial-gradient(circle at center, rgba(255,255,255,0.95), rgba(255,255,255,0.4));
      box-shadow: 0 0 12px rgba(255,255,255,0.9);
      opacity: 0.9;
    }
    .milk.hazard-highlight {
      animation: milkPulse 0.6s ease-in-out infinite alternate;
    }
    @keyframes milkPulse {
      from { transform: scale(1); opacity: 0.9; box-shadow: 0 0 10px rgba(255,255,255,0.6); }
      to   { transform: scale(1.08); opacity: 1;   box-shadow: 0 0 16px rgba(255,255,255,1); }
    }

    /* HUD */
    #hud {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      font-size: 13px;
      z-index: 5;
      text-shadow: 0 0 4px #000;
      align-items: center;
      flex-wrap: wrap;
      justify-content: center;
      max-width: 95vw;
    }
    #hud span.value {
      font-weight: 700;
    }

    /* –ü–æ–¥—Å–≤–µ—Ç–∫–∞, –∫–æ–≥–¥–∞ –ø–æ–±–∏—Ç —Ä–µ–∫–æ—Ä–¥ */
    #bestScore.beat-record {
      animation: recordPulse 0.6s ease-in-out infinite alternate;
    }
    @keyframes recordPulse {
      from { transform: scale(1); }
      to   { transform: scale(1.15); }
    }

    /* –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ–± –æ–ø–∞—Å–Ω–æ–π –∑–æ–Ω–µ */
    #hazardWarning {
      position: absolute;
      bottom: 235px;
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 10px;
      border-radius: 999px;
      background: rgba(255, 193, 7, 0.95);
      color: #000;
      font-size: 12px;
      font-weight: 700;
      text-shadow: none;
      opacity: 0;
      pointer-events: none;
      z-index: 7;
    }
    #hazardWarning.show {
      opacity: 1;
      animation: hazardBlink 0.4s ease-in-out infinite alternate;
    }
    @keyframes hazardBlink {
      from { transform: translateX(-50%) translateY(0); }
      to   { transform: translateX(-50%) translateY(-3px); }
    }

    /* –û–≤–µ—Ä–ª–µ–∏ */
    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0,0,0,0.75);
      z-index: 10;
      text-align: center;
      padding: 20px;
    }

    /* –ó–∞–≥—Ä—É–∑–æ—á–Ω—ã–π —ç–∫—Ä–∞–Ω —Å –∞–Ω–∏–º–∞—Ü–∏–µ–π —Ç–µ–∫—Å—Ç–∞ */
    #introScreen {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    #introScreen h1 {
      font-size: 26px;
      margin-bottom: 4px;
    }
    .intro-text {
      font-size: 18px;
      max-width: 280px;
      margin: 0 auto;
      opacity: 0;
      animation: fadeUp 2.2s ease-out forwards;
    }
    @keyframes fadeUp {
      0%   { opacity: 0; transform: translateY(16px); }
      60%  { opacity: 1; transform: translateY(0); }
      100% { opacity: 1; transform: translateY(0); }
    }

    button {
      border: none;
      padding: 10px 20px;
      border-radius: 999px;
      font-size: 16px;
      margin-top: 10px;
      background: #ffb300;
      color: #000;
      font-weight: 600;
      cursor: pointer;
    }
    button:active {
      transform: scale(0.96);
    }

    /* –≠–∫—Ä–∞–Ω Game Over */
    #gameOver {
      flex-direction: column;
      gap: 8px;
    }

    /* –≠–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ —Ä–µ–∂–∏–º–∞ */
    #modeScreen h2 {
      margin-bottom: 8px;
    }
    #modeScreen p {
      margin-top: 0;
      margin-bottom: 12px;
      font-size: 14px;
      opacity: 0.9;
    }
    #modeButtons {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .mode-btn {
      width: 220px;
      margin: 0 auto;
    }

    /* –õ–∏–¥–µ—Ä–±–æ—Ä–¥ */
    #leaderboard {
      margin-top: 10px;
      text-align: left;
      max-width: 260px;
      margin-left: auto;
      margin-right: auto;
      font-size: 14px;
    }
    #leaderboard h3 {
      margin: 6px 0;
      font-size: 16px;
      text-align: center;
    }
    #leaderboard ol {
      margin: 0;
      padding-left: 20px;
    }

    /* –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) */
    #raceControls {
      position: absolute;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 20px;
      z-index: 6;
    }
    .ctrl-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      background: rgba(255,255,255,0.12);
      color: #fff;
      font-size: 28px;
    }

    /* –í–∏–∑—É–∞–ª Nitro –∏ Slow-motion */
    .nitro-mode #road {
      background: #111;
      box-shadow: 0 0 40px rgba(255,120,0,0.9);
    }
    .slow-motion #road {
      filter: brightness(0.7);
    }

    /* –¢—Ä—è—Å–∫–∞ —ç–∫—Ä–∞–Ω–∞ –ø—Ä–∏ –∞–≤–∞—Ä–∏–∏ */
    .hit-shake {
      animation: hitShake 0.25s;
    }
    @keyframes hitShake {
      0%   { transform: translateX(0); }
      20%  { transform: translateX(-6px); }
      40%  { transform: translateX(6px); }
      60%  { transform: translateX(-4px); }
      80%  { transform: translateX(4px); }
      100% { transform: translateX(0); }
    }
  </style>
</head>
<body>
<div id="game">
  <div id="road">
    <div id="raceCar">
      <div id="nitroBarBg">
        <div id="nitroBarFill"></div>
      </div>
    </div>
  </div>

  <div id="hud">
    <div>–ò–≥—Ä–æ–∫: <span id="playerNameLabel" class="value">–ì–æ—Å—Ç—å</span></div>
    <div>–û–±–æ–≥–Ω–∞–ª: <span id="score" class="value">0</span></div>
    <div>–°–∫–æ—Ä–æ—Å—Ç—å: <span id="speed" class="value">0</span> –∫–º/—á</div>
    <div>–ñ–∏–∑–Ω–∏: <span id="lives" class="value">‚ù§Ô∏è</span></div>
    <div>–†–µ–∫–æ—Ä–¥: <span id="bestScore" class="value">0</span></div>
    <div>–ú–∏—Å—Å–∏—è: <span id="mission" class="value">‚Äî</span></div>
  </div>

  <!-- –ü—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ –æ–± –æ–ø–∞—Å–Ω–æ–π –∑–æ–Ω–µ -->
  <div id="hazardWarning">–°–∫–æ–ª—å–∑–∫–æ –≤–ø–µ—Ä–µ–¥–∏!</div>

  <!-- –≠–∫—Ä–∞–Ω –≤–≤–æ–¥–∞ –∏–º–µ–Ω–∏ -->
  <div id="introScreen" class="overlay" style="display:flex;">
    <div>
      <h1>–ö–æ—Ñ–µ-–¥—Ä–æ–º ‚òïüèÅ</h1>
      <p class="intro-text">
        –û–±—ä–µ–∑–∂–∞–π –º–∞—à–∏–Ω—ã, –ø–æ–∫–∞ –∂–¥—ë—à—å —Å–≤–æ–π –∫–æ—Ñ–µ.
      </p>

      <input id="playerNameInput"
             type="text"
             placeholder="–í–≤–µ–¥–∏ —Å–≤–æ—ë –∏–º—è"
             style="margin-top:12px;padding:8px 12px;border-radius:999px;border:none;width:220px;text-align:center;" />

      <button id="introBtn">–ü–æ–µ—Ö–∞–ª–∏</button>
    </div>
  </div>

  <!-- –≠–∫—Ä–∞–Ω –≤—ã–±–æ—Ä–∞ —Ä–µ–∂–∏–º–∞ -->
  <div id="modeScreen" class="overlay">
    <div>
      <h2>–í—ã–±–µ—Ä–∏ —Ä–µ–∂–∏–º</h2>
      <p>–ú–æ–∂–Ω–æ –ø—Ä–æ—Å—Ç–æ –∫–∞—Ç–∞—Ç—å—Å—è, –∏–≥—Ä–∞—Ç—å —Å –º–∏—Å—Å–∏—è–º–∏ –∏–ª–∏ —Å–æ—Å—Ä–µ–¥–æ—Ç–æ—á–∏—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –Ω–∞ —Ä–µ–∫–æ—Ä–¥–µ.</p>
      <div id="modeButtons">
        <button id="modeNormalBtn" class="mode-btn" style="background:#ffb300;">–û–±—ã—á–Ω—ã–π</button>
        <button id="modeMissionsBtn" class="mode-btn" style="background:#00e676;">–° –º–∏—Å—Å–∏—è–º–∏</button>
        <button id="modeRecordBtn" class="mode-btn" style="background:#ffcdd2;">–¢–æ–ª—å–∫–æ —Ä–µ–∫–æ—Ä–¥</button>
      </div>
    </div>
  </div>

  <!-- –≠–∫—Ä–∞–Ω Game Over -->
  <div id="gameOver" class="overlay">
    <h2>–§–∏–Ω–∏—à!</h2>
    <p>–°–µ–≥–æ–¥–Ω—è—à–Ω–∏–π –∑–∞–µ–∑–¥: <span id="finalScore">0</span> –º–∞—à–∏–Ω</p>
    <p>–¢–≤–æ–π —Ä–µ–∫–æ—Ä–¥: <span id="bestScoreEnd">0</span> –º–∞—à–∏–Ω</p>
    <p id="comment"></p>

    <div style="display:flex;flex-direction:column;gap:8px;margin-top:10px;">
      <button id="coffeeNotReadyBtn" style="background:#ffb300;">–ö–æ—Ñ–µ –µ—â—ë –Ω–µ –≥–æ—Ç–æ–≤</button>
      <button id="coffeeReadyBtn" style="background:#00e676;">–ö–æ—Ñ–µ –≥–æ—Ç–æ–≤</button>
      <button id="restartBtn" style="background:#ccc;">–ù–æ–≤—ã–π –∑–∞–µ–∑–¥</button>
    </div>

    <p id="coffeeMsg" style="margin-top:10px;font-size:16px;font-weight:500;"></p>

    <div id="leaderboard">
      <h3>–¢–æ–ø –ø–∏–ª–æ—Ç–æ–≤</h3>
      <ol id="leaderboardList"></ol>
    </div>
  </div>

  <!-- –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ) -->
  <div id="raceControls">
    <button class="ctrl-btn" id="leftBtn">‚óÄ</button>
    <button class="ctrl-btn" id="rightBtn">‚ñ∂</button>
  </div>
</div>

<script>
  /* ===== Firebase init ===== */
  const firebaseConfig = {
    apiKey: "AIzaSyBNfjarQbrPjloE--eAtl-RXeW11uPPXdc",
    authDomain: "coffe-drom.firebaseapp.com",
    databaseURL: "https://coffe-drom-default-rtdb.europe-west1.firebasedatabase.app",
    projectId: "coffe-drom",
    storageBucket: "coffe-drom.firebasestorage.app",
    messagingSenderId: "510024503818",
    appId: "1:510024503818:web:83b2a5258a7426a4a485f3"
  };

  firebase.initializeApp(firebaseConfig);
  const db = firebase.database();
  const bestScoreRef = db.ref('coffeeRacer/globalBestScore');
  const scoresRef = db.ref('coffeeRacer/scores');

  /* ===== Game State & Config ===== */
  const GAME_STATES = {
    INTRO: 'intro',
    RUNNING: 'running',
    GAME_OVER: 'gameOver'
  };

  const GAME_MODES = {
    NORMAL: 'normal',
    MISSIONS: 'missions',
    RECORD: 'record'
  };

  const ENTITY_TYPES = {
    ENEMY: 'enemy',
    BONUS_COFFEE: 'bonus_coffee',
    BONUS_HEART: 'bonus_heart',
    HAZARD_MILK: 'hazard_milk'
  };

  const ENEMY_VARIANTS = {
    NORMAL: 'normal',
    SLOW_TRUCK: 'slow_truck',
    FAST_BIKE: 'fast_bike'
  };

  const MISSION_TYPES = {
    SURVIVE: 'survive',
    COLLECT_COFFEE: 'collect_coffee',
    AGGRESSIVE: 'aggressive'
  };

  const GAME_CONFIG = {
    baseSpeed: 3,
    maxSpeed: 9,
    spawnIntervalStart: 900,
    spawnIntervalMin: 450,
    scoreForSpeedUp: 10,
    speedStep: 0.2,

    nitro: {
      duration: 2500,
      cooldown: 6000,
      multiplier: 2.2
    },

    slowMotion: {
      duration: 1200,
      factor: 0.5
    },

    skid: {
      duration: 900,
      force: 4
    },

    bonuses: {
      coffeeChance: 0.15,
      milkChance: 0.10,
      heartChance: 0.3
    }
  };

  let gameState = GAME_STATES.INTRO;
  let currentMode = GAME_MODES.NORMAL;

  /* ===== DOM ===== */
  const road = document.getElementById('road');
  const raceCar = document.getElementById('raceCar');
  const nitroBarFill = document.getElementById('nitroBarFill');

  const scoreEl = document.getElementById('score');
  const speedEl = document.getElementById('speed');
  const livesEl = document.getElementById('lives');
  const bestScoreEl = document.getElementById('bestScore');
  const playerNameLabel = document.getElementById('playerNameLabel');
  const missionLabel = document.getElementById('mission');

  const introScreen = document.getElementById('introScreen');
  const introBtn = document.getElementById('introBtn');
  const playerNameInput = document.getElementById('playerNameInput');

  const modeScreen = document.getElementById('modeScreen');
  const modeNormalBtn = document.getElementById('modeNormalBtn');
  const modeMissionsBtn = document.getElementById('modeMissionsBtn');
  const modeRecordBtn = document.getElementById('modeRecordBtn');

  const gameOver = document.getElementById('gameOver');
  const finalScoreEl = document.getElementById('finalScore');
  const bestScoreEndEl = document.getElementById('bestScoreEnd');
  const commentEl = document.getElementById('comment');
  const coffeeMsg = document.getElementById('coffeeMsg');
  const coffeeNotReadyBtn = document.getElementById('coffeeNotReadyBtn');
  const coffeeReadyBtn = document.getElementById('coffeeReadyBtn');
  const restartBtn = document.getElementById('restartBtn');

  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const gameEl = document.getElementById('game');
  const leaderboardList = document.getElementById('leaderboardList');
  const hazardWarning = document.getElementById('hazardWarning');

  let playerName = '–ì–æ—Å—Ç—å';

  function vibrate(pattern) {
    if (navigator.vibrate) {
      navigator.vibrate(pattern);
    }
  }

  const ROAD_MARGIN = 0;

  let laneLines = [];
  let entities = [];

  let score = 0;
  let speed = GAME_CONFIG.baseSpeed;
  let maxSpeed = GAME_CONFIG.maxSpeed;
  let lastSpawn = 0;
  let spawnInterval = GAME_CONFIG.spawnIntervalStart;
  let moveDirection = 0;
  const moveStep = 6;
  let running = false;
  let lastTime = 0;

  let lives = 1;
  const maxLives = 3;
  let invulnerableUntil = 0;

  let bestScore = 0;

  // Nitro
  let isNitroActive = false;
  let nitroEndTime = 0;
  let nitroCooldownEndTime = 0;

  // Slow-motion
  let isSlowMotionActive = false;
  let slowMotionEndTime = 0;

  // Skid
  let skidActive = false;
  let skidDirection = 0;
  let skidEndTime = 0;

  // Missions
  let currentMission = null;

  /* ===== HUD –∏ —Å–µ—Ä–≤–∏—Å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ===== */
  function updateLivesHUD() {
    livesEl.textContent = lives > 0 ? '‚ù§Ô∏è'.repeat(lives) : '‚Äî';
  }

  function updateMissionHUD() {
    if (currentMode !== GAME_MODES.MISSIONS) {
      missionLabel.textContent = '‚Äî';
      return;
    }
    if (!currentMission) {
      missionLabel.textContent = '–ú–∏—Å—Å–∏—è –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è...';
      return;
    }
    switch (currentMission.type) {
      case MISSION_TYPES.SURVIVE:
        missionLabel.textContent = `–í—ã–∂–∏–≤–∏ ${Math.round(currentMission.durationMs / 1000)} —Å–µ–∫`;
        break;
      case MISSION_TYPES.COLLECT_COFFEE:
        missionLabel.textContent = `–°–æ–±–µ—Ä–∏ –∫–æ—Ñ–µ: ${currentMission.progress}/${currentMission.target}`;
        break;
      case MISSION_TYPES.AGGRESSIVE:
        missionLabel.textContent = `–°–º–µ–ª—ã–µ –æ–±–≥–æ–Ω—ã: ${currentMission.progress}/${currentMission.target}`;
        break;
      default:
        missionLabel.textContent = '‚Äî';
    }
  }

  function startRandomMission() {
    if (currentMode !== GAME_MODES.MISSIONS) {
      currentMission = null;
      updateMissionHUD();
      return;
    }

    const r = Math.random();
    if (r < 0.33) {
      currentMission = {
        type: MISSION_TYPES.SURVIVE,
        durationMs: 25000,
        startedAt: performance.now(),
        completed: false
      };
    } else if (r < 0.66) {
      currentMission = {
        type: MISSION_TYPES.COLLECT_COFFEE,
        target: 3,
        progress: 0,
        completed: false
      };
    } else {
      currentMission = {
        type: MISSION_TYPES.AGGRESSIVE,
        target: 6,
        progress: 0,
        completed: false
      };
    }
    updateMissionHUD();
  }

  function completeMission() {
    if (!currentMission || currentMission.completed || currentMode !== GAME_MODES.MISSIONS) return;
    currentMission.completed = true;

    score += 15;
    scoreEl.textContent = score;
    vibrate([80, 40, 80]);
    showFloatingText('+15 –∑–∞ –º–∏—Å—Å–∏—é', raceCar.offsetLeft + 10, raceCar.offsetTop - 10);

    setTimeout(() => {
      startRandomMission();
    }, 1500);
  }

  function setGameState(newState) {
    gameState = newState;

    switch (newState) {
      case GAME_STATES.INTRO:
        introScreen.style.display = 'flex';
        modeScreen.style.display = 'none';
        gameOver.style.display = 'none';
        running = false;
        break;
      case GAME_STATES.RUNNING:
        introScreen.style.display = 'none';
        modeScreen.style.display = 'none';
        gameOver.style.display = 'none';
        running = true;
        lastTime = performance.now();
        requestAnimationFrame(gameLoop);
        break;
      case GAME_STATES.GAME_OVER:
        gameOver.style.display = 'flex';
        running = false;
        break;
    }
  }

  function loadGlobalBestScore() {
    bestScoreRef.once('value').then(snapshot => {
      const val = snapshot.val();
      if (typeof val === 'number') {
        bestScore = val;
        bestScoreEl.textContent = bestScore;
      } else {
        bestScore = 0;
        bestScoreEl.textContent = '0';
      }
    }).catch(err => {
      console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ä–µ–∫–æ—Ä–¥ –∏–∑ Firebase', err);
    });
  }

  function updateGlobalBestScoreIfNeeded(scoreValue) {
    bestScoreRef.transaction(current => {
      if (current === null || typeof current !== 'number') {
        return scoreValue;
      }
      return scoreValue > current ? scoreValue : current;
    }).then(result => {
      if (result.committed) {
        const newBest = result.snapshot.val();
        bestScore = newBest;
        bestScoreEl.textContent = bestScore;
        bestScoreEndEl.textContent = bestScore;
      }
    }).catch(err => {
      console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±–Ω–æ–≤–∏—Ç—å –≥–ª–æ–±–∞–ª—å–Ω—ã–π —Ä–µ–∫–æ—Ä–¥ –≤ Firebase', err);
    });
  }

  function submitScore(name, scoreValue) {
    const safeScore = Math.min(scoreValue, 10000);
    return scoresRef.push({
      name: name || '–ì–æ—Å—Ç—å',
      score: safeScore,
      ts: firebase.database.ServerValue.TIMESTAMP
    });
  }

  function loadLeaderboard() {
    leaderboardList.innerHTML = '<li>–ó–∞–≥—Ä—É–∑–∫–∞...</li>';
    scoresRef
      .orderByChild('score')
      .limitToLast(10)
      .once('value')
      .then(snapshot => {
        const list = [];
        snapshot.forEach(child => {
          list.push(child.val());
        });
        list.reverse();

        leaderboardList.innerHTML = '';
        if (list.length === 0) {
          leaderboardList.innerHTML = '<li>–ü–æ–∫–∞ –Ω–∏–∫—Ç–æ –Ω–µ –∏–≥—Ä–∞–ª</li>';
          return;
        }
        list.forEach((item) => {
          const li = document.createElement('li');
          li.textContent = `${item.name || '–ì–æ—Å—Ç—å'} ‚Äî ${item.score}`;
          leaderboardList.appendChild(li);
        });
      })
      .catch(err => {
        console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–∞–±–ª–∏—Ü—É –ª–∏–¥–µ—Ä–æ–≤', err);
        leaderboardList.innerHTML = '<li>–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</li>';
      });
  }

  /* ===== –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Ä–∞–∑–º–µ—Ä—ã –¥–æ—Ä–æ–≥–∏ ===== */
  function getRoadInnerMetrics() {
    const fullWidth = road.offsetWidth;
    const innerWidth = road.clientWidth;
    const border = (fullWidth - innerWidth) / 2;
    return { innerWidth, borderLeft: border };
  }

  /* ===== –†–∞–∑–º–µ—Ç–∫–∞ ===== */
  function createLaneLines() {
    const roadRect = road.getBoundingClientRect();
    const count = Math.ceil(roadRect.height / 80) + 2;
    laneLines.forEach(l => l.remove());
    laneLines = [];
    for (let i = 0; i < count; i++) {
      const line = document.createElement('div');
      line.className = 'lane-line';
      line.style.top = i * 80 + 'px';
      road.appendChild(line);
      laneLines.push(line);
    }
  }

  /* ===== –ú–∞—à–∏–Ω–∞ –ø–æ —Ü–µ–Ω—Ç—Ä—É ===== */
  function resetRaceCar() {
    const { innerWidth } = getRoadInnerMetrics();
    const carWidth = raceCar.offsetWidth || 40;
    let x = (innerWidth - carWidth) / 2;
    if (x < ROAD_MARGIN) x = ROAD_MARGIN;
    if (x > innerWidth - carWidth - ROAD_MARGIN) {
      x = innerWidth - carWidth - ROAD_MARGIN;
    }
    raceCar.style.left = x + 'px';
  }

  /* ===== –°—É—â–Ω–æ—Å—Ç–∏ ===== */
  function createEntity({ type, x, y, variant }) {
    const el = document.createElement('div');

    switch (type) {
      case ENTITY_TYPES.ENEMY:
        el.className = 'enemy';
        break;
      case ENTITY_TYPES.BONUS_COFFEE:
        el.className = 'bonus';
        el.textContent = '‚òï';
        break;
      case ENTITY_TYPES.BONUS_HEART:
        el.className = 'bonus heart';
        el.textContent = '‚ù§Ô∏è';
        break;
      case ENTITY_TYPES.HAZARD_MILK:
        el.className = 'milk';
        break;
    }

    el.style.left = x + 'px';
    el.style.top = y + 'px';
    road.appendChild(el);

    return {
      type,
      variant: variant || null,
      el,
      x,
      y,
      counted: false,
      meta: {}
    };
  }

  function spawnEnemy() {
    const { innerWidth } = getRoadInnerMetrics();
    const lanes = [
      innerWidth * 0.22,
      innerWidth * 0.5,
      innerWidth * 0.78
    ];
    const lane = lanes[Math.floor(Math.random() * lanes.length)];

    let variant = ENEMY_VARIANTS.NORMAL;
    const r = Math.random();
    if (r < 0.15) {
      variant = ENEMY_VARIANTS.SLOW_TRUCK;
    } else if (r < 0.30) {
      variant = ENEMY_VARIANTS.FAST_BIKE;
    }

    const enemy = createEntity({
      type: ENTITY_TYPES.ENEMY,
      x: lane - 20,
      y: -90,
      variant
    });

    if (variant === ENEMY_VARIANTS.SLOW_TRUCK) {
      enemy.el.style.height = '90px';
      enemy.el.style.background = '#6d4c41';
    } else if (variant === ENEMY_VARIANTS.FAST_BIKE) {
      enemy.el.style.width = '24px';
      enemy.el.style.background = '#ffeb3b';
    }

    entities.push(enemy);

    if (currentMode !== GAME_MODES.RECORD) {
      if (Math.random() < GAME_CONFIG.bonuses.coffeeChance) {
        spawnBonus();
      }
      if (Math.random() < GAME_CONFIG.bonuses.milkChance) {
        spawnMilk();
      }
    }
  }

  function spawnBonus() {
    const { innerWidth } = getRoadInnerMetrics();

    const isHeart = Math.random() < GAME_CONFIG.bonuses.heartChance;
    const type = isHeart ? ENTITY_TYPES.BONUS_HEART : ENTITY_TYPES.BONUS_COFFEE;

    const minX = ROAD_MARGIN + 10;
    const maxX = innerWidth - ROAD_MARGIN - 10;
    const left = minX + Math.random() * (maxX - minX);

    const bonus = createEntity({
      type,
      x: left,
      y: -60
    });

    entities.push(bonus);
  }

  function spawnMilk() {
    const { innerWidth } = getRoadInnerMetrics();
    const minX = ROAD_MARGIN + 10;
    const maxX = innerWidth - ROAD_MARGIN - 50;
    const left = minX + Math.random() * (maxX - minX);

    const milk = createEntity({
      type: ENTITY_TYPES.HAZARD_MILK,
      x: left,
      y: -60
    });

    entities.push(milk);
  }

  function removeEntity(index) {
    entities[index].el.remove();
    entities.splice(index, 1);
  }

  function isColliding(a, b) {
    return !(
      a.right < b.left ||
      a.left > b.right ||
      a.bottom < b.top ||
      a.top > b.bottom
    );
  }

  /* ===== –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ: —Ç–∞—á ===== */
  function setCarXFromClientX(clientX) {
    if (!running) return;

    const rect = road.getBoundingClientRect();
    const carWidth = raceCar.offsetWidth || 40;
    const { innerWidth, borderLeft } = getRoadInnerMetrics();

    let localX = clientX - rect.left - borderLeft;
    let x = localX - carWidth / 2;

    if (x < ROAD_MARGIN) x = ROAD_MARGIN;
    if (x > innerWidth - carWidth - ROAD_MARGIN) {
      x = innerWidth - carWidth - ROAD_MARGIN;
    }

    raceCar.style.left = x + 'px';
  }

  gameEl.addEventListener('pointerdown', (e) => {
    e.preventDefault();
    setCarXFromClientX(e.clientX);
  }, { passive: false });

  gameEl.addEventListener('pointermove', (e) => {
    if (!running) return;
    e.preventDefault();
    setCarXFromClientX(e.clientX);
  }, { passive: false });

  // –ö–Ω–æ–ø–∫–∏ –≤–ª–µ–≤–æ/–≤–ø—Ä–∞–≤–æ
  leftBtn.addEventListener('pointerdown', () => { moveDirection = -1; });
  rightBtn.addEventListener('pointerdown', () => { moveDirection = 1; });
  ['pointerup','pointerleave','pointercancel'].forEach(ev => {
    leftBtn.addEventListener(ev, () => moveDirection = 0);
    rightBtn.addEventListener(ev, () => moveDirection = 0);
  });

  function moveRaceCarButtons() {
    if (!running) return;
    const carWidth = raceCar.offsetWidth || 40;
    const { innerWidth } = getRoadInnerMetrics();

    let x = raceCar.offsetLeft + moveDirection * moveStep;
    if (x < ROAD_MARGIN) x = ROAD_MARGIN;
    if (x > innerWidth - carWidth - ROAD_MARGIN) {
      x = innerWidth - carWidth - ROAD_MARGIN;
    }
    raceCar.style.left = x + 'px';
  }

  /* ===== Nitro ===== */
  let lastTapTime = 0;

  function setNitroReadyVisual(isReady) {
    if (!nitroBarFill) return;
    if (isReady) {
      nitroBarFill.classList.add('ready');
    } else {
      nitroBarFill.classList.remove('ready');
    }
  }

  raceCar.addEventListener('pointerdown', (e) => {
    if (!running) return;
    const now = performance.now();
    if (now - lastTapTime < 300) {
      activateNitro(now);
    }
    lastTapTime = now;
  });

  raceCar.addEventListener('touchstart', (e) => {
    e.preventDefault();
  }, { passive: false });

  raceCar.addEventListener('dblclick', (e) => {
    e.preventDefault();
  }, { passive: false });

  function activateNitro(now) {
    if (!running) return;
    if (isNitroActive) return;
    if (now < nitroCooldownEndTime) return;
    isNitroActive = true;
    nitroEndTime = now + GAME_CONFIG.nitro.duration;
    gameEl.classList.add('nitro-mode');
    raceCar.classList.add('nitro-trail');
  }

  function updateNitroBar(timestamp) {
    if (!nitroBarFill) return;

    let ratio = 0;
    let opacity = 0.3;

    if (isNitroActive) {
      const remaining = Math.max(0, nitroEndTime - timestamp);
      ratio = remaining / GAME_CONFIG.nitro.duration;
      opacity = 1;
    } else if (timestamp < nitroCooldownEndTime) {
      const elapsed = GAME_CONFIG.nitro.cooldown - (nitroCooldownEndTime - timestamp);
      ratio = Math.max(0, Math.min(1, elapsed / GAME_CONFIG.nitro.cooldown));
      opacity = 0.6;
    } else {
      ratio = 1;
      opacity = 1;
    }

    nitroBarFill.style.height = (ratio * 100) + '%';
    nitroBarFill.style.opacity = opacity;

    const nitroReady = !isNitroActive && timestamp >= nitroCooldownEndTime;
    setNitroReadyVisual(nitroReady);
  }

  /* ===== Skid –æ—Ç –º–æ–ª–æ–∫–∞ ===== */
  function activateSkid(timestamp) {
    skidActive = true;
    skidDirection = Math.random() < 0.5 ? -1 : 1;
    skidEndTime = timestamp + GAME_CONFIG.skid.duration;

    gameEl.style.filter = "brightness(1.2)";
    setTimeout(() => {
      if (!isSlowMotionActive) gameEl.style.filter = "";
    }, 150);
  }

  /* ===== Slow motion ===== */
  function triggerSlowMotion(timestamp) {
    isSlowMotionActive = true;
    slowMotionEndTime = timestamp + GAME_CONFIG.slowMotion.duration;
    gameEl.classList.add('slow-motion');
  }

  function handleCollision(timestamp) {
    if (timestamp < invulnerableUntil) return;

    lives--;
    updateLivesHUD();
    vibrate([120, 60, 120]);
    triggerSlowMotion(timestamp);
    invulnerableUntil = timestamp + 1500;

    if (lives <= 0) {
      endGame();
    }
  }

  /* ===== Floating text ===== */
  function showFloatingText(text, x, y) {
    const el = document.createElement('div');
    el.textContent = text;
    el.style.position = 'absolute';
    el.style.left = x + 'px';
    el.style.top = y + 'px';
    el.style.fontSize = '12px';
    el.style.pointerEvents = 'none';
    el.style.textShadow = '0 0 4px #000';
    el.style.whiteSpace = 'nowrap';
    road.appendChild(el);

    el.animate([
      { transform: 'translateY(0)', opacity: 1 },
      { transform: 'translateY(-20px)', opacity: 0 }
    ], { duration: 600, easing: 'ease-out' });

    setTimeout(() => el.remove(), 650);
  }

  /* ===== –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—É—â–Ω–æ—Å—Ç–µ–π ===== */
  function updateEntities(timestamp, effectiveSpeed, playerRect, playerCenterX) {
    const roadRect = road.getBoundingClientRect();
    let hazardActive = false;

    for (let i = entities.length - 1; i >= 0; i--) {
      const ent = entities[i];

      if (ent.type === ENTITY_TYPES.ENEMY) {
        let mul = 2.2;
        if (ent.variant === ENEMY_VARIANTS.SLOW_TRUCK) {
          mul = 1.5;
        } else if (ent.variant === ENEMY_VARIANTS.FAST_BIKE) {
          mul = 3.0;
          if (Math.random() < 0.008) {
            const { innerWidth } = getRoadInnerMetrics();
            const lanes = [
              innerWidth * 0.22,
              innerWidth * 0.5,
              innerWidth * 0.78
            ];
            const newLane = lanes[Math.floor(Math.random() * lanes.length)];
            ent.x = newLane - (ent.el.offsetWidth / 2 || 12);
            ent.el.style.left = ent.x + 'px';
          }
        }
        ent.y += effectiveSpeed * mul;
      } else {
        ent.y += effectiveSpeed * 1.4;
      }
      ent.el.style.top = ent.y + 'px';

      const rect = ent.el.getBoundingClientRect();

      switch (ent.type) {
        case ENTITY_TYPES.ENEMY: {
          if (isColliding(playerRect, rect)) {
            handleCollision(timestamp);
            removeEntity(i);
            if (!running || lives <= 0) return false;
            continue;
          }

          if (!ent.counted && rect.top > playerRect.bottom) {
            const enemyCenterX = (rect.left + rect.right) / 2;
            const dx = Math.abs(enemyCenterX - playerCenterX);
            const closeThreshold = 18;
            const gained = dx < closeThreshold ? 2 : 1;

            score += gained;
            scoreEl.textContent = score;

            if (dx < closeThreshold) {
              showFloatingText('+2', playerCenterX - roadRect.left - 6, playerRect.top - roadRect.top - 10);
              if (currentMode === GAME_MODES.MISSIONS &&
                  currentMission && currentMission.type === MISSION_TYPES.AGGRESSIVE &&
                  !currentMission.completed) {
                currentMission.progress++;
                updateMissionHUD();
                if (currentMission.progress >= currentMission.target) {
                  completeMission();
                }
              }
            }

            if (score > 0 && score % GAME_CONFIG.scoreForSpeedUp === 0 && speed < maxSpeed) {
              speed += GAME_CONFIG.speedStep;
              spawnInterval = Math.max(GAME_CONFIG.spawnIntervalMin, spawnInterval - 10);
            }

            if (score > bestScore) {
              bestScoreEl.classList.add('beat-record');
            }

            ent.counted = true;
          }
          break;
        }

        case ENTITY_TYPES.BONUS_COFFEE: {
          if (isColliding(playerRect, rect)) {
            score += 5;
            scoreEl.textContent = score;
            vibrate(60);
            triggerSlowMotion(timestamp);

            if (currentMode === GAME_MODES.MISSIONS &&
                currentMission && currentMission.type === MISSION_TYPES.COLLECT_COFFEE &&
                !currentMission.completed) {
              currentMission.progress++;
              updateMissionHUD();
              if (currentMission.progress >= currentMission.target) {
                completeMission();
              }
            }

            removeEntity(i);
            continue;
          }
          break;
        }

        case ENTITY_TYPES.BONUS_HEART: {
          if (isColliding(playerRect, rect)) {
            if (lives < maxLives) {
              lives++;
              updateLivesHUD();
              vibrate(80);
            }
            removeEntity(i);
            continue;
          }
          break;
        }

        case ENTITY_TYPES.HAZARD_MILK: {
          const milkCenterX = (rect.left + rect.right) / 2;
          const dxMilk = Math.abs(milkCenterX - playerCenterX);
          const verticalAhead = rect.top > 0 && rect.top < playerRect.top;
          if (dxMilk < 40 && verticalAhead) {
            hazardActive = true;
            ent.el.classList.add('hazard-highlight');
          } else {
            ent.el.classList.remove('hazard-highlight');
          }

          if (isColliding(playerRect, rect)) {
            vibrate(40);
            activateSkid(timestamp);
            removeEntity(i);
            continue;
          }
          break;
        }
      }

      if (ent.y > roadRect.height + 100) {
        removeEntity(i);
      }
    }

    hazardWarning.classList.toggle('show', hazardActive);
    return true;
  }

  /* ===== –û—Å–Ω–æ–≤–Ω–æ–π –∞–ø–¥–µ–π—Ç ===== */
  function updateGame(timestamp) {
    let speedFactor = 1;

    if (isSlowMotionActive) {
      if (timestamp >= slowMotionEndTime) {
        isSlowMotionActive = false;
        gameEl.classList.remove('slow-motion');
        gameEl.style.filter = "";
      } else {
        speedFactor *= GAME_CONFIG.slowMotion.factor;
      }
    }

    if (isNitroActive) {
      if (timestamp >= nitroEndTime) {
        isNitroActive = false;
        nitroCooldownEndTime = timestamp + GAME_CONFIG.nitro.cooldown;
        gameEl.classList.remove('nitro-mode');
        raceCar.classList.remove('nitro-trail');
      } else {
        speedFactor *= GAME_CONFIG.nitro.multiplier;
      }
    }

    updateNitroBar(timestamp);

    const effectiveSpeed = speed * speedFactor;
    const kmh = Math.round(effectiveSpeed * 20);
    speedEl.textContent = kmh;

    laneLines.forEach(line => {
      let top = parseFloat(line.style.top);
      top += effectiveSpeed * 2;
      const roadRect = road.getBoundingClientRect();
      if (top > roadRect.height) top = -40;
      line.style.top = top + 'px';
    });

    moveRaceCarButtons();

    const roadRect = road.getBoundingClientRect();
    const playerRect = raceCar.getBoundingClientRect();
    const playerCenterX = (playerRect.left + playerRect.right) / 2;

    if (skidActive) {
      if (timestamp >= skidEndTime) {
        skidActive = false;
        if (!isSlowMotionActive) {
          gameEl.style.filter = "";
        }
      } else {
        const carWidth = raceCar.offsetWidth || 40;
        const { innerWidth } = getRoadInnerMetrics();
        let x = raceCar.offsetLeft + skidDirection * GAME_CONFIG.skid.force;

        if (x < ROAD_MARGIN) {
          x = ROAD_MARGIN;
          skidDirection *= -1;
        }
        if (x > innerWidth - carWidth - ROAD_MARGIN) {
          x = innerWidth - carWidth - ROAD_MARGIN;
          skidDirection *= -1;
        }

        raceCar.style.left = x + 'px';
      }
    }

    if (currentMode === GAME_MODES.MISSIONS &&
        currentMission && currentMission.type === MISSION_TYPES.SURVIVE &&
        !currentMission.completed) {
      const now = performance.now();
      if (now - currentMission.startedAt >= currentMission.durationMs) {
        completeMission();
      }
    }

    if (!updateEntities(timestamp, effectiveSpeed, playerRect, playerCenterX)) {
      return;
    }

    if (timestamp - lastSpawn > spawnInterval) {
      spawnEnemy();
      lastSpawn = timestamp;
    }
  }

  function gameLoop(timestamp) {
    if (!running) return;
    const delta = timestamp - lastTime;
    lastTime = timestamp;
    updateGame(timestamp, delta);
    requestAnimationFrame(gameLoop);
  }

  function startGame() {
    entities.forEach(e => e.el.remove());
    entities = [];

    score = 0;
    speed = GAME_CONFIG.baseSpeed;
    spawnInterval = GAME_CONFIG.spawnIntervalStart;
    moveDirection = 0;
    scoreEl.textContent = score;
    speedEl.textContent = '0';
    bestScoreEl.classList.remove('beat-record');

    lives = 1;
    invulnerableUntil = 0;
    updateLivesHUD();

    createLaneLines();
    raceCar.style.display = 'block';
    resetRaceCar();

    gameOver.style.display = 'none';
    coffeeMsg.textContent = '';
    hazardWarning.classList.remove('show');

    isNitroActive = false;
    nitroEndTime = 0;
    nitroCooldownEndTime = 0;
    isSlowMotionActive = false;
    slowMotionEndTime = 0;
    skidActive = false;
    gameEl.classList.remove('nitro-mode');
    gameEl.classList.remove('slow-motion');
    gameEl.style.filter = "";
    raceCar.classList.remove('nitro-trail');
    updateNitroBar(performance.now());

    if (currentMode === GAME_MODES.MISSIONS) {
      startRandomMission();
    } else {
      currentMission = null;
      updateMissionHUD();
    }

    loadGlobalBestScore();

    running = true;
    lastTime = performance.now();
    lastSpawn = lastTime;
  }

  function endGame() {
    running = false;

    vibrate([80, 40, 120]);
    gameEl.classList.add('hit-shake');
    setTimeout(() => {
      gameEl.classList.remove('hit-shake');
    }, 250);

    finalScoreEl.textContent = score;

    updateGlobalBestScoreIfNeeded(score);
    submitScore(playerName, score).then(() => {
      loadLeaderboard();
    });

    let text = '';
    if (score < 10) text = '–ü–æ—Ö–æ–∂–µ, —Ç—ã —Ç–æ–ª—å–∫–æ –≤—ã–µ—Ö–∞–ª –∏–∑ –±–æ–∫—Å–∞.';
    else if (score < 25) text = '–ù–µ–ø–ª–æ—Ö–æ –≤–æ–¥–∏—à—å! üëå';
    else text = '–¢—ã –Ω–∞—Å—Ç–æ—è—â–∏–π –ø–∏–ª–æ—Ç –∞–≤—Ç–æ–¥—Ä–æ–º–∞! üòé';

    commentEl.textContent = text;
    coffeeMsg.textContent = '';

    setGameState(GAME_STATES.GAME_OVER);
  }

  /* ===== –ö–Ω–æ–ø–∫–∏ Game Over ===== */
  coffeeNotReadyBtn.onclick = () => {
    coffeeMsg.textContent = '–ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑, –µ—Å–ª–∏ –∫–æ—Ñ–µ –µ—â—ë –Ω–µ –≥–æ—Ç–æ–≤ ‚òï';
    setTimeout(() => {
      startGame();
      setGameState(GAME_STATES.RUNNING);
    }, 1200);
  };

  coffeeReadyBtn.onclick = () => {
    coffeeMsg.textContent = '–ù–∞—Å–ª–∞–∂–¥–∞–π—Ç–µ—Å—å –Ω–∞–ø–∏—Ç–∫–æ–º ‚òï';
  };

  restartBtn.onclick = () => {
    coffeeMsg.textContent = '';
    startGame();
    setGameState(GAME_STATES.RUNNING);
  };

  /* ===== –≠–∫—Ä–∞–Ω –∏–º–µ–Ω–∏ –∏ –≤—ã–±–æ—Ä —Ä–µ–∂–∏–º–∞ ===== */
  introBtn.onclick = () => {
    const name = (playerNameInput.value || '').trim();
    playerName = name || '–ì–æ—Å—Ç—å';
    playerNameLabel.textContent = playerName;
    introScreen.style.display = 'none';
    modeScreen.style.display = 'flex';
  };

  function chooseMode(mode) {
    currentMode = mode;
    modeScreen.style.display = 'none';
    startGame();
    setGameState(GAME_STATES.RUNNING);
  }

  modeNormalBtn.onclick = () => chooseMode(GAME_MODES.NORMAL);
  modeMissionsBtn.onclick = () => chooseMode(GAME_MODES.MISSIONS);
  modeRecordBtn.onclick = () => chooseMode(GAME_MODES.RECORD);

  /* ===== –ë–ª–æ–∫–∏—Ä–æ–≤–∫–∞ —Å–∫—Ä–æ–ª–ª–∞ –∏ –∑—É–º–∞ ===== */
  (function preventScrolling() {
    const block = (e) => e.preventDefault();

    window.addEventListener('scroll', block, { passive: false });
    window.addEventListener('wheel', block, { passive: false });
    window.addEventListener('touchmove', block, { passive: false });

    window.addEventListener('touchstart', (e) => {
      if (e.touches.length > 1) e.preventDefault();
    }, { passive: false });

    document.body.addEventListener('touchmove', (e) => {
      e.preventDefault();
    }, { passive: false });

    document.addEventListener('gesturestart', (e) => e.preventDefault(), { passive: false });

    document.addEventListener('dblclick', (e) => {
      e.preventDefault();
    }, { passive: false });
  })();
</script>
</body>
</html>
